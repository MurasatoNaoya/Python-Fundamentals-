# A for loop commits all of the values generated by it into memory. 
# This is no problem when dealing with small ranges, but commiting a list 1 to 1*10^6 would be unnecessarily inefficient. 

# Here's an example of a normal function, that commits all information to memory. 
def create_cubes(n):
    result = []
    for num in range(n):
        result.append(num**3)
    return result


for num in create_cubes(10):
    print(num)


# We could rearrange this for-loop to show that we only really needed the cubed values one at a time, instead of commiting a whole list to memory. 
for num in create_cubes(4):
    print(num)

# A generator function allows you to produce a list of values by keeping count track of your previous value. 
# While keeping your stepsize into account for your next value. 

def gen_create_cubes(n):
    result = [] # This is the committing to memory part. 
    for _ in range(n):
        yield(_**3)       # The yield keyword produces values as they come, instead of producing, commiting to memory then outputing the whole thing. 
# The yield keyword is essentially the return keyword, except the function will return a generator. 
# If you then want the result of the generator in a list form, then you can always just cast it to a list. 



print(list(gen_create_cubes(4)))


# We can use the idea of generators for more specific things, like the fibonacci sequence for example. 
 
def gen_fibonacci(n):  # In this case 'n' is the number of cycles you want the fibonacci sequence to go for. 
    a=1
    b=1 
    for _ in range(n):
        yield a 
        a,b = b,a+b

# You can then use another for loop to print the yielded values. 
for _ in gen_fibonacci(10):
    print(_)



# The next key points to understanding generators, are the next and iter keywords. 

# Consider a simple generator. 


def a_simple_gen():
    for _ in range(3):
        yield(_) 

# We can create an instance of this function for no specified range, z.  

z = a_simple_gen()

# The next keyword allows us to see the next value that the generator would be considering and what would be 'yielded'. 

print(next(z))
print(next(z))
print(next(z))

# The for loop uses the next keyword internally to consider the next value in the iteration. 
# If you use the next keyword when your range has been exhausted, then you will be met with an 'iteration error'. 
# The for loop internally does not produce this however, and accounts for this iteraiton error. 

# Next is the iter function, that allows us to make objects that you can iterate through become 'iterators' through objects that you wouldn't expect. 
# As we know, we can iterate through a string using a for loop. 

s = 'hello' 

# Individually or indivudally in a list. 
for _ in s:
    print(_)


iteration_list = []
for _ in s:
    iteration_list.append(_)

print(iteration_list)
  
# However, if we were to apply the next keyword to s, we would get an error saying that 's' is not an iterator. 
# To allow us to make s an iterator, we must apply the iter keyword to s. 

s_iter = iter(s)

print(next(s_iter))
print(next(s_iter))
print(next(s_iter))
print(next(s_iter))
print(next(s_iter))

# In short, the iter keyword is important when trying to convery ITERABLE objects, into ITERATORS. 